High level functionality:
This program, UVsim, will read in a text file containing a basicML program written one command per line. Each basicML command will be a four-digit signed word. UVsim will convert the first two digits into one of 12 operations. The second two will be an operand. The operations include: 10-read, 11-write, 20-load, 21-store, 30-add, 31-subtract, 32-divide, 33-multiply, 40-branch, 41-branchneg, 42-branchzero, and 43-halt.
User Stories:
“As a student, I want to be able to write programs in basicML and have a virtual machine interpret my program, so that I can learn basic programming skills in basicML.”
“ As a teacher, I want to have a tool that I can use to teach basicML and computer architecture ideas, so that students can have a better understanding of coding and the underlying machine language.”
Use cases:
WRITE function prints word stored in memory to terminal.
LOAD function stores a word in the accumulator from specified memory location.
STORE function stores word in accumulator in specified memory location.
ADD function adds a word in specified memory location to word in accumulator. Stores result in accumulator.
SUBTRACT function subtracts a word in specified memory location from word in accumulator. Stores result in accumulator.
DIVIDE function divides the word in the accumulator by a word from a specified memory location. Stores result in accumulator.
MULTIPLY function multiplies a word in specified memory location with word in accumulator. Stores result in accumulator.
BRANCH function branches to specified memory location.
BRANCHNEG function if accumulator is negative, branches to specified memory location.
BRANCHZERO function if accumulator is zero, branches to specified memory location.
HALT function stops running the program.

Anna's use cases:
Add
    Actor: test_add function
    System: math
    Goal: Successfully add the numbers 1000 and 100

    Steps:
        1. parse function code
        2. get memory address (1)
        3. takes the word and returns the number in the address (1000)
        4. adds that word to the number in the accumulator (100)
        5. accumulator then equals 1100
    
    Actor: test_add_fail function
    System: UVsim
    Goal: Successfully add the numbers 1000 and 2000

    Steps:
        1. parse function code
        2. get memory address (1)
        3. takes the word and returns the number in the address (1000)
        4. adds that word to the number int he accumulator (2000)
        5. make sure the accumulator doesn't equal 500

Divide
    Actor: test_divide function
    System: UVsim
    Goal: Successfully divide numbers 

    Steps:
        1. parse function code
        2. get memory address (1)
        3. takes the word and returns the number in the address (1000)
        4. divides that word to the number int he accumulator (2000)
        5. make sure the accumulator is equal to 2

    Actor: test_divide_fail
    System: math
    Goal: Successfully divide numbers

    Steps:
        1. parse function code
        2. get memory address (1)
        3. takes the word and returns the number in the address (500)
        4. divides that word to the number int he accumulator (4000)
        5. make sure the accumulator is not equal to 300

BranchNeg
    Actor: test_branchneg
    System: Registers dictionary
    Goal: When the accumulator is negative, branch to specified memory location

    Steps: 
        1. parse function code for specified memory location
        2. get the number in the accumulator (-2)
        3. if the number is negative return specified location (1)
        4. go to that location -1 so it actually starts on the location specified.

    Actor: test_branchnotneg
    System: Registers dictionary
    Goal: when the accumulator is not negative it goes back to the current index

    Steps:
        1. parse function code for specified memory location
        2. get the number in the accumulator (10)
        3. if the number is negative return specified location
        4. the number is not negative so it returns to the current index (6)

Cameron's use cases:
    Actor: Read function
    System: Main program
    Goal: takes a terminal input and stores to memory.
    steps:
        1.Parse function code.
        2.Request input to be stored.
        3.Find memory location.
        4.Store input value.

    Actor: Write function
    System: Main program
    Goal: takes a value from a given memory location and prints it to the screen.
    Steps:
        1.Parse function code.
        2.Find memory location.
        3.Print value to console.
        
